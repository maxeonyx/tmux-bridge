#!/usr/bin/env fish
#
# tmux-send: Send commands to the tmux-bridge session
#
# COMMAND MODE (default):
#   tmux-send [flags] -- command [args...]
#   Runs a shell command with markers to capture stdout/stderr/exit status.
#
# REPL MODE:
#   tmux-send --repl NAME [flags] -- text to send
#   tmux-send --prompt REGEX [flags] -- text to send
#   Sends text, waits for prompt, returns all output including prompt.
#
# CONTROL:
#   tmux-send --close        Clean close: Ctrl-C, Ctrl-U, Ctrl-D
#   tmux-send --ctrl-c       Send Ctrl-C (interrupt)
#   tmux-send --ctrl-d       Send Ctrl-D (EOF)
#
# FLAGS:
#   --timeout N      No-output timeout in seconds (default: 10)
#   --max-time N     Overall timeout in seconds (default: 120)
#   --help           Show this help
#   --repl-list      Show available REPL presets
#
# REPL FLAGS:
#   --repl NAME           Use a preset (python, node, psql, nix)
#   --prompt REGEX        Custom prompt regex
#   --eval-template TPL   Wrap expression with markers (for dynamic prompts)
#
# EXAMPLES:
#   # Shell command (with exit status)
#   tmux-send -- ls -la
#
#   # Start a REPL
#   tmux-send --repl psql -- psql -d mydb
#
#   # Evaluate in REPL
#   tmux-send --repl psql -- "SELECT 1 + 1;"
#
#   # Close REPL
#   tmux-send --close

set -g session_name "tmux-bridge-$USER"
set -g no_output_timeout 10
set -g max_time 120

#------------------------------------------------------------------------------
# REPL Presets
#------------------------------------------------------------------------------

function get_repl_prompt --argument-names name
    switch $name
        case python python3
            echo "^>>>|^\\.\\.\\."
        case node nodejs
            echo "^>"
        case psql postgres postgresql
            echo "^[a-z_0-9]+=[#>]"
        case nix nix-repl
            echo "^nix-repl>"
        case '*'
            return 1
    end
end

function show_repl_list
    echo "Available REPL presets:"
    echo ""
    echo "  python   Prompt: ^>>>|^\\.\\.\\."
    echo "  node     Prompt: ^>"
    echo "  psql     Prompt: ^[a-z_0-9]+=[#>]"
    echo "  nix      Prompt: ^nix-repl>"
    echo ""
    echo "Usage: tmux-send --repl NAME -- command or expression"
    echo "Custom: tmux-send --prompt \"^myrepl>\" -- text"
end

# Mode and options
set -l mode command
set -l repl_preset ""
set -l repl_prompt ""
set -l repl_eval_template ""

# Parse arguments
set -l args
set -l parsing_flags true

set -l i 1
while test $i -le (count $argv)
    set -l arg $argv[$i]
    
    if test "$parsing_flags" = true
        switch $arg
            case --timeout
                set i (math $i + 1)
                set no_output_timeout $argv[$i]
            case --max-time
                set i (math $i + 1)
                set max_time $argv[$i]
            case --repl
                set mode repl
                set i (math $i + 1)
                set repl_preset $argv[$i]
            case --prompt
                set mode repl
                set i (math $i + 1)
                set repl_prompt $argv[$i]
            case --eval-template
                set i (math $i + 1)
                set repl_eval_template $argv[$i]
            case --close
                set mode close
            case --ctrl-c
                set mode ctrl-c
            case --ctrl-d
                set mode ctrl-d
            case --repl-list
                set mode repl-list
            case --help
                head -40 (status filename) | tail -38 | string replace -r '^# ?' ''
                exit 0
            case --
                set parsing_flags false
            case '*'
                set parsing_flags false
                set args $args $arg
        end
    else
        set args $args $arg
    end
    
    set i (math $i + 1)
end

# Help if no args
if test "$mode" = command -a (count $args) -eq 0
    echo "Usage: tmux-send [--repl NAME | --prompt REGEX] -- text..." >&2
    echo "       tmux-send -- command [args...]" >&2
    echo "       tmux-send --close | --ctrl-c | --ctrl-d" >&2
    echo "" >&2
    echo "Run 'tmux-send --help' for full documentation." >&2
    echo "Run 'tmux-send --repl-list' for REPL presets." >&2
    exit 1
end

# Handle simple modes that don't need session check
if test "$mode" = repl-list
    show_repl_list
    exit 0
end

# Check session exists
if not tmux has-session -t $session_name 2>/dev/null
    echo "Error: No tmux-bridge session is running." >&2
    echo "" >&2
    echo "The user needs to start tmux-bridge first." >&2
    echo "Ask them to run: tmux-bridge" >&2
    exit 1
end

# Handle control modes
if test "$mode" = close
    tmux send-keys -t $session_name C-c
    sleep 0.1
    tmux send-keys -t $session_name C-u
    sleep 0.1
    tmux send-keys -t $session_name C-d
    exit 0
end

if test "$mode" = ctrl-c
    tmux send-keys -t $session_name C-c
    exit 0
end

if test "$mode" = ctrl-d
    tmux send-keys -t $session_name C-d
    exit 0
end

# Resolve preset
if test "$mode" = repl -a -n "$repl_preset"
    set -l preset_prompt (get_repl_prompt $repl_preset)
    if test $status -ne 0
        echo "Error: Unknown preset '$repl_preset'" >&2
        echo "Run 'tmux-send --repl-list' for options." >&2
        exit 1
    end
    
    test -z "$repl_prompt" && set repl_prompt $preset_prompt
end

# Validate
if test "$mode" = repl -a -z "$repl_prompt"
    echo "Error: Need --repl NAME or --prompt REGEX" >&2
    exit 1
end

if test "$mode" = repl -a (count $args) -eq 0
    echo "Error: Need text to send after --" >&2
    exit 1
end

#------------------------------------------------------------------------------
# REPL Mode
#------------------------------------------------------------------------------

if test "$mode" = repl
    # Preserve newlines in single arg, join multiple args with space
    if test (count $args) -eq 1
        set text "$args[1]"
    else
        set text (string join ' ' -- $args)
    end
    set -l expr_id (random)(random)
    
    # Apply template if provided
    set -l text_to_send $text
    if test -n "$repl_eval_template"
        set text_to_send (string replace -a "{expr}" "$text" -- $repl_eval_template)
        set text_to_send (string replace -a "{id}" "$expr_id" -- $text_to_send)
    end
    
    # Send with -l (literal mode) - no escaping needed
    tmux send-keys -t $session_name C-u
    sleep 0.1
    tmux send-keys -l -t $session_name "$text_to_send"
    tmux send-keys -t $session_name Enter
    
    # Wait for prompt
    set -l start_time (date +%s)
    set -l last_output_time $start_time
    set -l last_content ""
    
    while true
        set -l content (tmux capture-pane -t $session_name -p -S - 2>/dev/null)
        if test $status -ne 0
            echo "Error: tmux-bridge session closed." >&2
            exit 1
        end
        
        if test "$content" != "$last_content"
            set last_output_time (date +%s)
            set last_content $content
        end
        
        # Check if last non-empty line matches prompt
        set -l lines (string split \n -- $content)
        for i in (seq (count $lines) -1 1)
            set -l line $lines[$i]
            if test -n "$line"
                if string match -rq -- $repl_prompt $line
                    # Output last 20 non-empty lines from pane
                    tmux capture-pane -t $session_name -p | grep -v '^$' | tail -20
                    exit 0
                end
                break
            end
        end
        
        # Timeouts
        set -l now (date +%s)
        if test (math $now - $last_output_time) -ge $no_output_timeout
            tmux send-keys -t $session_name C-c
            echo "---" >&2
            echo "Timeout: no output for $no_output_timeout seconds. Sent Ctrl-C." >&2
            echo "Use --timeout N for slow operations." >&2
            echo "---" >&2
            # Show last 20 non-empty lines from pane
            tmux capture-pane -t $session_name -p | grep -v '^$' | tail -20
            exit 124
        end
        if test (math $now - $start_time) -ge $max_time
            tmux send-keys -t $session_name C-c
            echo "---" >&2
            echo "Timeout: exceeded $max_time seconds. Sent Ctrl-C." >&2
            echo "---" >&2
            # Show last 20 non-empty lines from pane
            tmux capture-pane -t $session_name -p | grep -v '^$' | tail -20
            exit 124
        end
        
        sleep 0.1
    end
end

#------------------------------------------------------------------------------
# Command Mode
#------------------------------------------------------------------------------

set -l cmd_id (random)(random)
set -l start_marker "___START_"$cmd_id"___"
set -l end_marker "___END_"$cmd_id"_"

# Build command string - preserve newlines in single arg
if test (count $args) -eq 1
    set cmd_string "$args[1]"
else
    set cmd_string (string join ' ' -- $args)
end

# Detect shell for exit status syntax
set -l shell_name (tmux display-message -t $session_name -p '#{pane_current_command}')
set -l exit_var '$?'
test "$shell_name" = fish && set exit_var '$status'

# Build inline command: echo START; command; echo END_$?
set -l inline_cmd "echo '$start_marker'; $cmd_string; echo '$end_marker'$exit_var"

# Send
tmux send-keys -t $session_name C-u
sleep 0.1
tmux send-keys -t $session_name "$inline_cmd" Enter

# Wait for completion
set -l start_time (date +%s)
set -l last_output_time $start_time
set -l last_content ""

while true
    set -l content (tmux capture-pane -t $session_name -p -S - 2>/dev/null)
    if test $status -ne 0
        echo "Error: tmux-bridge session closed." >&2
        exit 1
    end
    
    if test "$content" != "$last_content"
        set last_output_time (date +%s)
        set last_content $content
    end
    
    # Check for END marker at start of line (not in command echo)
    if string match -rq "(^|\n)___END_"$cmd_id"_" -- $content
        set -l all_lines (string split \n -- $content)
        set -l in_output false
        set -l output_lines
        set -l exit_status 0
        
        # Search for our specific markers
        # Start marker must be exact match (the echo output, not the command)
        # End marker starts with our pattern (has exit status appended)
        for line in $all_lines
            if test "$line" = "$start_marker"
                set in_output true
                continue
            end
            # End marker must start at beginning of line (not in a command echo)
            if string match -rq "^___END_"$cmd_id"_" -- $line
                set -l match (string match -r "___END_"$cmd_id"_(\d+)" -- $line)
                test (count $match) -ge 2 && set exit_status $match[2]
                break
            end
            if test "$in_output" = true
                set output_lines $output_lines $line
            end
        end
        
        for line in $output_lines
            echo $line
        end
        exit $exit_status
    end
    
    # Timeouts
    set -l now (date +%s)
    if test (math $now - $last_output_time) -ge $no_output_timeout
        tmux send-keys -t $session_name C-c
        sleep 3
        tmux send-keys -t $session_name C-\\
        echo "---" >&2
        echo "Timeout: no output for $no_output_timeout seconds." >&2
        echo "---" >&2
        # Show last 20 non-empty lines from pane
        tmux capture-pane -t $session_name -p | grep -v '^$' | tail -20
        exit 124
    end
    
    if test (math $now - $start_time) -ge $max_time
        tmux send-keys -t $session_name C-c
        sleep 3
        tmux send-keys -t $session_name C-\\
        echo "---" >&2
        echo "Timeout: exceeded $max_time seconds." >&2
        echo "---" >&2
        # Show last 20 non-empty lines from pane
        tmux capture-pane -t $session_name -p | grep -v '^$' | tail -20
        exit 124
    end
    
    sleep 0.1
end
