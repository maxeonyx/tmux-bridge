#!/usr/bin/env fish
#
# tmux-send: Send commands to the tmux-bridge session
#
# COMMAND MODE (default):
#   tmux-send [flags] -- command [args...]
#   Runs a shell command, captures output, returns exit status.
#
# REPL MODE:
#   tmux-send --repl NAME [flags] -- text to send
#   tmux-send --prompt REGEX [flags] -- text to send
#   Sends text, waits for prompt, returns all output including prompt.
#
# CONTROL:
#   tmux-send --close        Clean close: Ctrl-C, Ctrl-U, Ctrl-D
#   tmux-send --ctrl-c       Send Ctrl-C (interrupt)
#   tmux-send --ctrl-d       Send Ctrl-D (EOF)
#
# FLAGS:
#   --timeout N      No-output timeout in seconds (default: 10)
#   --max-time N     Overall timeout in seconds (default: 120)
#   --first N        Lines to show from start (default: 20)
#   --last N         Lines to show from end (default: 20)
#   --width N        Chars per line, 0 for unlimited (default: 0)
#   --help           Show this help
#   --repl-list      Show available REPL presets
#
# REPL FLAGS:
#   --repl NAME           Use a preset (python, node, psql, nix)
#   --prompt REGEX        Custom prompt regex
#   --eval-template TPL   Wrap expression with markers (for dynamic prompts)
#
# EXAMPLES:
#   # Shell command (with exit status)
#   tmux-send -- ls -la
#
#   # Limit output
#   tmux-send --first 10 --last 30 -- make build
#
#   # Start a REPL
#   tmux-send --repl psql -- psql -d mydb
#
#   # Evaluate in REPL
#   tmux-send --repl psql -- "SELECT 1 + 1;"
#
#   # Close REPL
#   tmux-send --close

set -g session_name "tmux-bridge-$USER"
set -g no_output_timeout 10
set -g max_time 120
set -g trunc_first 50
set -g trunc_last 50
set -g trunc_width 400

#------------------------------------------------------------------------------
# REPL Presets
#------------------------------------------------------------------------------

function get_repl_prompt --argument-names name
    switch $name
        case python python3
            echo "^>>>|^\\.\\.\\."
        case node nodejs
            echo "^>"
        case psql postgres postgresql
            echo "^[a-z_0-9]+=[#>]"
        case nix nix-repl
            echo "^nix-repl>"
        case '*'
            return 1
    end
end

function show_repl_list
    echo "Available REPL presets:"
    echo ""
    echo "  python   Prompt: ^>>>|^\\.\\.\\."
    echo "  node     Prompt: ^>"
    echo "  psql     Prompt: ^[a-z_0-9]+=[#>]"
    echo "  nix      Prompt: ^nix-repl>"
    echo ""
    echo "Usage: tmux-send --repl NAME -- command or expression"
    echo "Custom: tmux-send --prompt \"^myrepl>\" -- text"
end

#------------------------------------------------------------------------------
# Output truncation helpers
#------------------------------------------------------------------------------

# Truncate a single line to max width
function truncate_line --argument-names line width
    if test $width -eq 0; or test (string length -- "$line") -le $width
        echo "$line"
    else
        echo (string sub -l (math $width - 3) -- "$line")"..."
    end
end

# Truncate output: first N lines + [...] + last M lines
# Each line also truncated to W chars
function truncate_output --argument-names first_count last_count width
    set -l lines
    while read -l line
        set -a lines "$line"
    end
    
    set -l total (count $lines)
    
    if test $total -le (math $first_count + $last_count)
        # No truncation needed
        for line in $lines
            truncate_line "$line" $width
        end
    else
        # Output first N
        for i in (seq 1 $first_count)
            truncate_line "$lines[$i]" $width
        end
        
        # Truncation indicator
        set -l skipped (math $total - $first_count - $last_count)
        echo "[... $skipped lines truncated ...]"
        
        # Output last M
        set -l start (math $total - $last_count + 1)
        for i in (seq $start $total)
            truncate_line "$lines[$i]" $width
        end
    end
end

#------------------------------------------------------------------------------
# Argument parsing
#------------------------------------------------------------------------------

# Mode and options
set -l mode command
set -l repl_preset ""
set -l repl_prompt ""
set -l repl_eval_template ""

# Parse arguments
set -l args
set -l parsing_flags true

set -l i 1
while test $i -le (count $argv)
    set -l arg $argv[$i]
    
    if test "$parsing_flags" = true
        switch $arg
            case --timeout
                set i (math $i + 1)
                set no_output_timeout $argv[$i]
            case --max-time
                set i (math $i + 1)
                set max_time $argv[$i]
            case --first
                set i (math $i + 1)
                set trunc_first $argv[$i]
            case --last
                set i (math $i + 1)
                set trunc_last $argv[$i]
            case --width
                set i (math $i + 1)
                set trunc_width $argv[$i]
            case --repl
                set mode repl
                set i (math $i + 1)
                set repl_preset $argv[$i]
            case --prompt
                set mode repl
                set i (math $i + 1)
                set repl_prompt $argv[$i]
            case --eval-template
                set i (math $i + 1)
                set repl_eval_template $argv[$i]
            case --close
                set mode close
            case --ctrl-c
                set mode ctrl-c
            case --ctrl-d
                set mode ctrl-d
            case --repl-list
                set mode repl-list
            case --help
                head -48 (status filename) | tail -46 | string replace -r '^# ?' ''
                exit 0
            case --
                set parsing_flags false
            case '*'
                set parsing_flags false
                set args $args $arg
        end
    else
        set args $args $arg
    end
    
    set i (math $i + 1)
end

# Help if no args
if test "$mode" = command -a (count $args) -eq 0
    echo "Usage: tmux-send [--repl NAME | --prompt REGEX] -- text..." >&2
    echo "       tmux-send -- command [args...]" >&2
    echo "       tmux-send --close | --ctrl-c | --ctrl-d" >&2
    echo "" >&2
    echo "Run 'tmux-send --help' for full documentation." >&2
    echo "Run 'tmux-send --repl-list' for REPL presets." >&2
    exit 1
end

# Handle simple modes that don't need session check
if test "$mode" = repl-list
    show_repl_list
    exit 0
end

# Check session exists
if not tmux has-session -t $session_name 2>/dev/null
    echo "Error: No tmux-bridge session is running." >&2
    echo "" >&2
    echo "The user needs to start tmux-bridge first." >&2
    echo "Ask them to run: tmux-bridge" >&2
    exit 1
end

# Handle control modes
if test "$mode" = close
    tmux send-keys -t $session_name C-c
    sleep 0.1
    tmux send-keys -t $session_name C-u
    sleep 0.1
    tmux send-keys -t $session_name C-d
    sleep 0.3
    # Show the resulting pane state
    echo "Sent Ctrl-C, Ctrl-U, Ctrl-D"
    tmux capture-pane -t $session_name -p | grep -v '^$' | tail -5
    exit 0
end

if test "$mode" = ctrl-c
    tmux send-keys -t $session_name C-c
    sleep 0.2
    echo "Sent Ctrl-C"
    tmux capture-pane -t $session_name -p | grep -v '^$' | tail -3
    exit 0
end

if test "$mode" = ctrl-d
    tmux send-keys -t $session_name C-d
    sleep 0.2
    echo "Sent Ctrl-D"
    tmux capture-pane -t $session_name -p | grep -v '^$' | tail -3
    exit 0
end

# Resolve preset
if test "$mode" = repl -a -n "$repl_preset"
    set -l preset_prompt (get_repl_prompt $repl_preset)
    if test $status -ne 0
        echo "Error: Unknown preset '$repl_preset'" >&2
        echo "Run 'tmux-send --repl-list' for options." >&2
        exit 1
    end
    
    test -z "$repl_prompt" && set repl_prompt $preset_prompt
end

# Validate
if test "$mode" = repl -a -z "$repl_prompt"
    echo "Error: Need --repl NAME or --prompt REGEX" >&2
    exit 1
end

if test "$mode" = repl -a (count $args) -eq 0
    echo "Error: Need text to send after --" >&2
    exit 1
end

#------------------------------------------------------------------------------
# REPL Mode
#------------------------------------------------------------------------------

if test "$mode" = repl
    # Preserve newlines in single arg, join multiple args with space
    if test (count $args) -eq 1
        set text "$args[1]"
    else
        set text (string join ' ' -- $args)
    end
    set -l expr_id (random)(random)
    
    # Apply template if provided
    set -l text_to_send $text
    if test -n "$repl_eval_template"
        set text_to_send (string replace -a "{expr}" "$text" -- $repl_eval_template)
        set text_to_send (string replace -a "{id}" "$expr_id" -- $text_to_send)
    end
    
    # Workaround: tmux -l strips trailing semicolons, so append a space
    if string match -qr ';$' -- "$text_to_send"
        set text_to_send "$text_to_send "
    end
    
    # Capture pane state before sending
    set -l before_content (tmux capture-pane -t $session_name -p -S - 2>/dev/null)
    set -l before_lines (printf "%s\n" $before_content | grep -cv '^$')
    
    # Send the text
    tmux send-keys -t $session_name C-u
    sleep 0.1
    tmux send-keys -l -t $session_name "$text_to_send"
    tmux send-keys -t $session_name Enter
    
    # Poll capture-pane for prompt
    set -l start_time (date +%s)
    set -l last_output_time $start_time
    set -l last_content "$before_content"
    
    while true
        # Capture current pane content
        set -l content (tmux capture-pane -t $session_name -p -S - 2>/dev/null)
        if test $status -ne 0
            echo "Error: tmux-bridge session closed." >&2
            exit 1
        end
        
        # Track output activity
        if test "$content" != "$last_content"
            set last_output_time (date +%s)
            set last_content "$content"
        end
        
        # Check for prompt on last non-empty line
        set -l last_line (printf "%s\n" $content | grep -v '^$' | tail -1)
        if test -n "$last_line"
            if string match -rq -- $repl_prompt "$last_line"
                # Success - output new content with truncation
                # Get lines after what we had before
                set -l all_lines (printf "%s\n" $content | tail -n +$before_lines)
                printf "%s\n" $all_lines | truncate_output $trunc_first $trunc_last $trunc_width
                exit 0
            end
        end
        
        # Timeouts
        set -l now (date +%s)
        if test (math $now - $last_output_time) -ge $no_output_timeout
            tmux send-keys -t $session_name C-c
            echo "---" >&2
            echo "Timeout: no output for $no_output_timeout seconds. Sent Ctrl-C." >&2
            echo "Use --timeout N for slow operations." >&2
            echo "---" >&2
            tmux capture-pane -t $session_name -p | tail -20
            exit 124
        end
        if test (math $now - $start_time) -ge $max_time
            tmux send-keys -t $session_name C-c
            echo "---" >&2
            echo "Timeout: exceeded $max_time seconds. Sent Ctrl-C." >&2
            echo "---" >&2
            tmux capture-pane -t $session_name -p | tail -20
            exit 124
        end
        
        sleep 0.1
    end
end

#------------------------------------------------------------------------------
# Command Mode
#------------------------------------------------------------------------------

set -l cmd_id (random)(random)
set -l start_marker "___START_"$cmd_id"___"
set -l end_marker_pattern "___END_"$cmd_id"_[0-9]+___"

# Build command string - preserve newlines in single arg, quote multi-arg
if test (count $args) -eq 1
    set cmd_string "$args[1]"
else
    # Quote args that contain spaces or special chars
    set -l quoted_args
    for arg in $args
        if string match -qr '[ ;&|<>()$`"'"'"']' -- $arg; or string match -q '*\\*' -- $arg
            # Escape single quotes and wrap in single quotes
            set -l escaped (string replace -a "'" "'\\''" -- $arg)
            set quoted_args $quoted_args "'"$escaped"'"
        else
            set quoted_args $quoted_args $arg
        end
    end
    set cmd_string (string join ' ' -- $quoted_args)
end

# Detect shell for exit status syntax
set -l shell_name (tmux display-message -t $session_name -p '#{pane_current_command}')
set -l exit_var '$?'
test "$shell_name" = fish && set exit_var '$status'

# Build command: echo START; command; echo END_status
set -l inline_cmd "echo '$start_marker'; $cmd_string; echo \"___END_"$cmd_id"_\""$exit_var"\"___\""

# Send
tmux send-keys -t $session_name C-u
sleep 0.1
tmux send-keys -t $session_name "$inline_cmd" Enter

# Poll capture-pane for completion
set -l start_time (date +%s)
set -l last_output_time $start_time
set -l last_content ""

while true
    # Capture current pane content
    set -l content (tmux capture-pane -t $session_name -p -S - 2>/dev/null)
    if test $status -ne 0
        echo "Error: tmux-bridge session closed." >&2
        exit 1
    end
    
    # Track output activity
    if test "$content" != "$last_content"
        set last_output_time (date +%s)
        set last_content "$content"
    end
    
    # Check for END marker
    set -l match (printf "%s\n" $content | grep -oE "$end_marker_pattern" | tail -1)
    if test -n "$match"
        # Extract exit status
        set -l exit_status (string replace -r "___END_"$cmd_id"_([0-9]+)___" '$1' -- "$match")
        if test -z "$exit_status"
            echo "Error: Failed to parse exit status." >&2
            exit 1
        end
        
        # Get all lines between START and END markers (anchored to match exact lines)
        set -l all_output (printf "%s\n" $content | sed -n "/^$start_marker\$/,/^$match\$/p" | tail -n +2 | head -n -1)
        set -l total_lines (count $all_output)
        
        # Output with truncation
        if test $total_lines -le (math $trunc_first + $trunc_last)
            # No truncation needed - output all with line width truncation
            for line in $all_output
                truncate_line "$line" $trunc_width
            end
        else
            # Output first N lines
            for i in (seq 1 $trunc_first)
                truncate_line "$all_output[$i]" $trunc_width
            end
            
            # Truncation indicator
            set -l skipped (math $total_lines - $trunc_first - $trunc_last)
            echo "[... $skipped lines truncated ...]"
            
            # Output last M lines
            set -l start_idx (math $total_lines - $trunc_last + 1)
            for i in (seq $start_idx $total_lines)
                truncate_line "$all_output[$i]" $trunc_width
            end
        end
        
        exit $exit_status
    end
    
    # Timeouts
    set -l now (date +%s)
    if test (math $now - $last_output_time) -ge $no_output_timeout
        tmux send-keys -t $session_name C-c
        sleep 3
        tmux send-keys -t $session_name C-\\
        echo "---" >&2
        echo "Timeout: no output for $no_output_timeout seconds." >&2
        echo "---" >&2
        # Output what we have
        tmux capture-pane -t $session_name -p | tail -20
        exit 124
    end
    
    if test (math $now - $start_time) -ge $max_time
        tmux send-keys -t $session_name C-c
        sleep 3
        tmux send-keys -t $session_name C-\\
        echo "---" >&2
        echo "Timeout: exceeded $max_time seconds." >&2
        echo "---" >&2
        tmux capture-pane -t $session_name -p | tail -20
        exit 124
    end
    
    sleep 0.1
end
