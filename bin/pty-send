#!/usr/bin/env fish
#
# pty-send: Send commands to the PTY bridge session
#
# COMMAND MODE (default):
#   pty-send [flags] -- command [args...]
#   Runs a shell command and captures stdout/stderr/exit status.
#
# REPL MODE:
#   pty-send --repl-start CMD --prompt REGEX [--eval-template TPL]
#   pty-send --repl-eval EXPR
#   pty-send --repl-close
#
#   Start a REPL, send expressions, and close it. Supports nesting.
#
# FLAGS:
#   --timeout N      No-output timeout in seconds (default: 10)
#   --max-time N     Overall timeout in seconds (default: 120)
#   --help           Show this help
#
# REPL FLAGS:
#   --repl-start CMD      Start REPL with given command
#   --prompt REGEX        Regex to detect REPL prompt (required with --repl-start)
#   --eval-template TPL   Template for wrapping expressions (optional)
#                         Use {expr} as placeholder. Use {id} for unique marker ID.
#                         Default: just sends expression directly
#   --repl-eval EXPR      Send expression to current REPL
#   --repl-close          Close current REPL (sends Ctrl-D)
#
# EXAMPLES:
#   # Command mode
#   pty-send -- ls -la
#   pty-send --timeout 30 -- make build
#
#   # Python REPL
#   pty-send --repl-start python3 --prompt "^>>> |^\.\.\. " \
#     --eval-template 'print("___START_{id}___"); {expr}; print("___END_{id}___")'
#   pty-send --repl-eval "1 + 1"
#   pty-send --repl-close
#
#   # Nix REPL
#   pty-send --repl-start "nix repl" --prompt "^nix-repl> "
#   pty-send --repl-eval "1 + 1"
#   pty-send --repl-close

set -g session_name "pty-bridge-$USER"
set -g runtime_dir /tmp/pty-bridge-$USER

# Default timeouts (global so functions can access them)
set -g no_output_timeout 10
set -g max_time 120

# REPL mode variables
set -l mode command  # command, repl-start, repl-eval, repl-close
set -l repl_cmd ""
set -l repl_prompt ""
set -l repl_eval_template ""
set -l repl_expr ""

# Parse arguments
set -l args
set -l parsing_flags true

set -l i 1
while test $i -le (count $argv)
    set -l arg $argv[$i]
    
    if test "$parsing_flags" = true
        switch $arg
            case --timeout
                set i (math $i + 1)
                set no_output_timeout $argv[$i]
            case --max-time
                set i (math $i + 1)
                set max_time $argv[$i]
            case --repl-start
                set mode repl-start
                set i (math $i + 1)
                set repl_cmd $argv[$i]
            case --prompt
                set i (math $i + 1)
                set repl_prompt $argv[$i]
            case --eval-template
                set i (math $i + 1)
                set repl_eval_template $argv[$i]
            case --repl-eval
                set mode repl-eval
                set i (math $i + 1)
                set repl_expr $argv[$i]
            case --repl-close
                set mode repl-close
            case --help
                # Print header comment as help
                head -45 (status filename) | tail -43 | string replace -r '^# ?' ''
                exit 0
            case --
                set parsing_flags false
            case '*'
                # Unknown flag or start of command without --
                set parsing_flags false
                set args $args $arg
        end
    else
        set args $args $arg
    end
    
    set i (math $i + 1)
end

# Validation
if test "$mode" = command -a (count $args) -eq 0
    echo "pty-send: Send commands to a user-controlled terminal session" >&2
    echo "" >&2
    echo "COMMAND MODE (run shell commands):" >&2
    echo "  pty-send [flags] -- command [args...]" >&2
    echo "" >&2
    echo "REPL MODE (interactive interpreters):" >&2
    echo "  pty-send --repl-start CMD --prompt REGEX   Start a REPL" >&2
    echo "  pty-send --repl-eval EXPR                  Evaluate expression" >&2
    echo "  pty-send --repl-close                      Close REPL (Ctrl-D)" >&2
    echo "" >&2
    echo "EXAMPLES:" >&2
    echo "  pty-send -- sudo apt install foo" >&2
    echo "  pty-send --repl-start python3 --prompt \"^>>>\"" >&2
    echo "  pty-send --repl-eval \"1 + 1\"" >&2
    echo "" >&2
    echo "Run 'pty-send --help' for full documentation." >&2
    exit 1
end

if test "$mode" = repl-start
    if test -z "$repl_cmd"
        echo "Error: --repl-start requires a command" >&2
        echo "" >&2
        echo "Usage: pty-send --repl-start CMD --prompt REGEX" >&2
        echo "" >&2
        echo "Example:" >&2
        echo "  pty-send --repl-start python3 --prompt \"^>>>\"" >&2
        echo "  pty-send --repl-start \"nix repl\" --prompt \"^nix-repl>\"" >&2
        exit 1
    end
    if test -z "$repl_prompt"
        echo "Error: --repl-start requires --prompt REGEX" >&2
        echo "" >&2
        echo "The prompt regex tells pty-send how to detect when the REPL is ready for input." >&2
        echo "It should match the beginning of the REPL's prompt line." >&2
        echo "" >&2
        echo "Examples:" >&2
        echo "  Python:  --prompt \"^>>>\"" >&2
        echo "  Nix:     --prompt \"^nix-repl>\"" >&2
        echo "  Node:    --prompt \"^>\"" >&2
        exit 1
    end
end

# Check if session exists
if not tmux has-session -t $session_name 2>/dev/null
    echo "Error: No PTY bridge session is running." >&2
    echo "" >&2
    echo "You have used pty-send, but it currently has nowhere to send to." >&2
    echo "" >&2
    echo "The user needs to start the interactive backing terminal using pty-bridge." >&2
    echo "Do not try this yourself - instead, ask the user to do it for you." >&2
    echo "" >&2
    echo "This is necessary for *interactive* commands - for example, sudo (requiring" >&2
    echo "a password prompt). If you can avoid interactive tools, then prefer that." >&2
    echo "Otherwise, please ask the user now." >&2
    exit 1
end

mkdir -p $runtime_dir

#------------------------------------------------------------------------------
# REPL State Management
#------------------------------------------------------------------------------

set -g repl_depth_file $runtime_dir/repl.depth

function get_repl_depth
    if test -f $repl_depth_file
        cat $repl_depth_file
    else
        echo 0
    end
end

function get_repl_config
    set -l depth (get_repl_depth)
    if test $depth -eq 0
        return 1
    end
    set -l config_file $runtime_dir/repl.(math $depth - 1)
    if test -f $config_file
        cat $config_file
        return 0
    end
    return 1
end

function push_repl_config --argument-names prompt eval_template
    set -l depth (get_repl_depth)
    set -l config_file $runtime_dir/repl.$depth
    echo "prompt=$prompt" > $config_file
    echo "eval_template=$eval_template" >> $config_file
    echo (math $depth + 1) > $repl_depth_file
end

function pop_repl_config
    set -l depth (get_repl_depth)
    if test $depth -eq 0
        return 1
    end
    set -l new_depth (math $depth - 1)
    rm -f $runtime_dir/repl.$new_depth
    if test $new_depth -eq 0
        rm -f $repl_depth_file
    else
        echo $new_depth > $repl_depth_file
    end
end

function read_repl_config
    set -l config (get_repl_config)
    or return 1
    for line in (string split \n -- $config)
        if string match -q "prompt=*" -- $line
            set -g current_repl_prompt (string replace "prompt=" "" -- $line)
        else if string match -q "eval_template=*" -- $line
            set -g current_repl_eval_template (string replace "eval_template=" "" -- $line)
        end
    end
end

#------------------------------------------------------------------------------
# Wait for prompt (used by REPL mode)
#------------------------------------------------------------------------------

function wait_for_prompt --argument-names prompt_regex
    set -l start_time (date +%s)
    set -l last_output_time $start_time
    set -l last_content ""
    
    while true
        set -l content (tmux capture-pane -t $session_name -p -S -)
        
        if test "$content" != "$last_content"
            set last_output_time (date +%s)
            set last_content $content
        end
        
        # Find last non-empty line and check if it matches prompt
        set -l lines (string split \n -- $content)
        for i in (seq (count $lines) -1 1)
            set -l line $lines[$i]
            if test -n "$line"
                if string match -rq -- $prompt_regex $line
                    return 0
                end
                # Found non-empty line but it didn't match - keep waiting
                break
            end
        end
        
        # Check timeouts
        set -l now (date +%s)
        if test (math $now - $last_output_time) -ge $no_output_timeout
            echo "Error: Timed out waiting for REPL prompt (no output for $no_output_timeout seconds)." >&2
            return 124
        end
        if test (math $now - $start_time) -ge $max_time
            echo "Error: Timed out waiting for REPL prompt (exceeded $max_time seconds)." >&2
            return 124
        end
        
        sleep 0.1
    end
end

#------------------------------------------------------------------------------
# REPL Mode: Start
#------------------------------------------------------------------------------

if test "$mode" = repl-start
    echo "[pty-send] Starting REPL: $repl_cmd" >&2
    
    # Send the command to start the REPL
    tmux send-keys -t $session_name C-u
    sleep 0.1
    tmux send-keys -t $session_name "$repl_cmd" Enter
    
    # Wait for the REPL prompt
    if not wait_for_prompt $repl_prompt
        echo "Error: REPL did not show expected prompt." >&2
        echo "" >&2
        echo "The REPL command was sent but the expected prompt was not detected." >&2
        echo "Expected prompt regex: $repl_prompt" >&2
        echo "" >&2
        echo "Try these fixes first:" >&2
        echo "  1. Increase timeout: --timeout 30" >&2
        echo "  2. Simplify the regex (e.g., \"^>>>\" instead of \"^>>> \")" >&2
        echo "  3. Use --repl-close to clean up, then try again" >&2
        echo "" >&2
        echo "If the problem persists, ask the user to check the pty-bridge terminal" >&2
        echo "and describe what they see (error message, unexpected prompt, etc.)." >&2
        exit 1
    end
    
    # Save REPL config
    push_repl_config $repl_prompt $repl_eval_template
    
    echo "[pty-send] REPL ready (depth: "(get_repl_depth)")" >&2
    exit 0
end

#------------------------------------------------------------------------------
# REPL Mode: Close
#------------------------------------------------------------------------------

if test "$mode" = repl-close
    set -l depth (get_repl_depth)
    if test $depth -eq 0
        echo "Error: No REPL session to close." >&2
        echo "" >&2
        echo "pty-send has no record of an active REPL session." >&2
        echo "" >&2
        echo "If the REPL exited unexpectedly, the terminal may still be in a usable state." >&2
        echo "Try running a command to verify: pty-send -- echo hello" >&2
        echo "" >&2
        echo "To start a fresh REPL session:" >&2
        echo "  pty-send --repl-start python3 --prompt \"^>>>\"" >&2
        exit 1
    end
    
    echo "[pty-send] Closing REPL (depth: $depth)" >&2
    
    # Send Ctrl-D to exit the REPL
    tmux send-keys -t $session_name C-d
    sleep 0.3
    
    # Pop the config
    pop_repl_config
    
    # If there's a parent REPL, wait for its prompt
    if test (get_repl_depth) -gt 0
        read_repl_config
        wait_for_prompt $current_repl_prompt
    end
    
    exit 0
end

#------------------------------------------------------------------------------
# REPL Mode: Eval
#------------------------------------------------------------------------------

if test "$mode" = repl-eval
    if not read_repl_config
        echo "Error: No REPL session. Use --repl-start first." >&2
        echo "" >&2
        echo "Before evaluating expressions, you need to start a REPL session:" >&2
        echo "  pty-send --repl-start python3 --prompt \"^>>>\"" >&2
        echo "  pty-send --repl-start \"nix repl\" --prompt \"^nix-repl>\"" >&2
        echo "" >&2
        echo "Then you can evaluate expressions:" >&2
        echo "  pty-send --repl-eval \"1 + 1\"" >&2
        echo "" >&2
        echo "When done, close the REPL:" >&2
        echo "  pty-send --repl-close" >&2
        exit 1
    end
    
    set -l expr_id (random)(random)
    set -l start_marker "___REPL_START_"$expr_id"___"
    set -l end_marker "___REPL_END_"$expr_id"___"
    
    # Build the expression to send
    set -l expr_to_send $repl_expr
    if test -n "$current_repl_eval_template"
        # Replace {expr} and {id} in template
        set expr_to_send (string replace -a "{expr}" "$repl_expr" -- $current_repl_eval_template)
        set expr_to_send (string replace -a "{id}" "$expr_id" -- $expr_to_send)
        set start_marker "___REPL_START_"$expr_id"___"
        set end_marker "___REPL_END_"$expr_id"___"
    else
        # No template - we'll detect output between prompts
        set start_marker ""
        set end_marker ""
    end
    
    # Clear line and send expression
    tmux send-keys -t $session_name C-u
    sleep 0.1
    tmux send-keys -t $session_name "$expr_to_send" Enter
    
    # Wait for output and next prompt
    set -l start_time (date +%s)
    set -l last_output_time $start_time
    set -l last_content ""
    
    while true
        set -l content (tmux capture-pane -t $session_name -p -S -)
        
        if test "$content" != "$last_content"
            set last_output_time (date +%s)
            set last_content $content
        end
        
        # If we have markers, look for them
        if test -n "$start_marker" -a -n "$end_marker"
            if string match -q "*$end_marker*" -- $content
                # Extract output between markers
                set -l in_output false
                set -l output_lines
                
                for line in (string split \n -- $content)
                    if string match -q "*$start_marker*" -- $line
                        set in_output true
                        continue
                    end
                    if string match -q "*$end_marker*" -- $line
                        break
                    end
                    if test "$in_output" = true
                        set output_lines $output_lines $line
                    end
                end
                
                # Output result
                for line in $output_lines
                    echo $line
                end
                exit 0
            end
        else
            # No markers - wait for prompt and extract output between command echo and prompt
            set -l all_lines (string split \n -- $content)
            set -l expr_line_idx 0
            
            # Find the LAST occurrence by searching forward and updating each time
            for i in (seq 1 (count $all_lines))
                if string match -q "*$repl_expr*" -- $all_lines[$i]
                    set expr_line_idx $i
                end
            end
            
            if test $expr_line_idx -gt 0
                set -l output_lines
                
                # Look at lines after the expression
                for i in (seq (math $expr_line_idx + 1) (count $all_lines))
                    set -l line $all_lines[$i]
                    
                    # Check if this line is a prompt
                    if string match -rq -- $current_repl_prompt $line
                        # Found prompt - output what we collected
                        for out_line in $output_lines
                            echo $out_line
                        end
                        exit 0
                    end
                    
                    # Collect output (skip empty lines at start)
                    if test -n "$line" -o (count $output_lines) -gt 0
                        set output_lines $output_lines $line
                    end
                end
            end
        end
        
        # Check timeouts
        set -l now (date +%s)
        if test (math $now - $last_output_time) -ge $no_output_timeout
            echo "Error: REPL eval timed out (no output for $no_output_timeout seconds)." >&2
            echo "" >&2
            echo "The REPL did not return to its prompt after the expression was sent." >&2
            echo "" >&2
            echo "Try these fixes:" >&2
            echo "  1. For slow operations, increase timeout: --timeout 30" >&2
            echo "  2. If the expression was incomplete (multi-line), send remaining input" >&2
            echo "  3. Close and restart the REPL: pty-send --repl-close" >&2
            echo "" >&2
            echo "If the problem persists, ask the user to check the pty-bridge terminal" >&2
            echo "and describe what the REPL is showing." >&2
            exit 124
        end
        if test (math $now - $start_time) -ge $max_time
            echo "Error: REPL eval timed out (exceeded $max_time seconds)." >&2
            echo "" >&2
            echo "The expression took too long. Use --max-time N for longer operations." >&2
            exit 124
        end
        
        sleep 0.1
    end
end

#------------------------------------------------------------------------------
# Command Mode (original behavior)
#------------------------------------------------------------------------------

# Generate unique ID for this command
set -l cmd_id (random)(random)
set -l start_marker "___PTYSEND_START_"$cmd_id"___"
set -l end_marker "___PTYSEND_END_"$cmd_id"_"

# Create stderr capture file
set -l stderr_file $runtime_dir/stderr.$cmd_id

# Build the command string by properly escaping for the shell
set -l escaped_args
for arg in $args
    set -a escaped_args (printf '%s' $arg | string escape)
end
set -l cmd_string (string join ' ' -- $escaped_args)

# Write command to temp script file to avoid line-wrapping issues
set -l cmd_file $runtime_dir/cmd.$cmd_id

# Detect the shell running in the tmux session
set -l shell_name (tmux display-message -t $session_name -p '#{pane_current_command}')

# Generate shell-appropriate script (fish uses $status, bash uses $?)
if test "$shell_name" = fish
    set cmd_file "$cmd_file.fish"
    echo "echo '[pty-send] $cmd_string'
echo $start_marker
$cmd_string 2>$stderr_file
echo $end_marker\$status" > $cmd_file
else
    set cmd_file "$cmd_file.sh"
    echo "echo '[pty-send] $cmd_string'
echo $start_marker
$cmd_string 2>$stderr_file
echo $end_marker\$?" > $cmd_file
end

sync

# Source the script file
set -l wrapped_cmd ". $cmd_file"

# Send the command to tmux
tmux send-keys -t $session_name C-u
sleep 0.1
tmux send-keys -t $session_name "$wrapped_cmd" Enter

# Poll for completion
set -l start_time (date +%s)
set -l last_output_time $start_time
set -l last_content ""

while true
    set -l content (tmux capture-pane -t $session_name -p -S -1000)
    
    if test "$content" != "$last_content"
        set last_output_time (date +%s)
        set last_content $content
    end
    
    # Check for end marker
    if string match -q "*$end_marker*" -- $content
        set -l in_output false
        set -l output_lines
        set -l exit_status 0
        set -l found_end false
        
        for line in (string split \n -- $content)
            if test -z "$line" -a "$in_output" = false
                continue
            end
            
            if test "$line" = "$start_marker"
                set in_output true
                continue
            end
            
            if string match -q "*$end_marker*" -- $line
                set -l match (string match -r "___PTYSEND_END_"$cmd_id"_(\d+)" -- $line)
                if test (count $match) -ge 2
                    set exit_status $match[2]
                end
                set found_end true
                break
            end
            
            if test "$in_output" = true
                set output_lines $output_lines $line
            end
        end
        
        if test "$found_end" = true
            for line in $output_lines
                echo $line
            end
            
            if test -f $stderr_file
                cat $stderr_file >&2
                rm -f $stderr_file
            end
            
            rm -f $cmd_file
            exit $exit_status
        end
    end
    
    # Check no-output timeout
    set -l now (date +%s)
    set -l idle_time (math $now - $last_output_time)
    if test $idle_time -ge $no_output_timeout
        echo "Error: Command timed out (no output for $no_output_timeout seconds)." >&2
        echo "" >&2
        echo "The command was terminated. For slow commands, use --timeout N." >&2
        echo "" >&2
        echo "If the command is waiting for input (password, confirmation), ask the" >&2
        echo "user to check the pty-bridge terminal and provide the required input." >&2
        tmux send-keys -t $session_name C-c
        sleep 3
        tmux send-keys -t $session_name C-\\
        rm -f $stderr_file $cmd_file
        exit 124
    end
    
    # Check overall timeout
    set -l elapsed (math $now - $start_time)
    if test $elapsed -ge $max_time
        echo "Error: Command timed out (exceeded $max_time seconds total)." >&2
        echo "" >&2
        echo "The command was terminated. Use --max-time N for longer operations." >&2
        tmux send-keys -t $session_name C-c
        sleep 3
        tmux send-keys -t $session_name C-\\
        rm -f $stderr_file $cmd_file
        exit 124
    end
    
    sleep 0.1
end
